CREATE TABLE Users (
  UserID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  Name VARCHAR2(100) NOT NULL,
  Email VARCHAR2(100) NOT NULL UNIQUE,
  PasswordHash VARCHAR2(255) NOT NULL,
  Role VARCHAR2(50) NOT NULL,
  CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE Calculations (
  CalcID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  UserID NUMBER NOT NULL,
  Num1 NUMBER NOT NULL,
  Num2 NUMBER NOT NULL,
  Operator VARCHAR2(1) CHECK (Operator IN ('+', '-', '*', '/')),
  Result NUMBER,
  CalcTimestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  Version NUMBER DEFAULT 1,
  FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE
);

CREATE TABLE AuditLogs (
  LogID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  TableName VARCHAR2(50) NOT NULL,
  Operation VARCHAR2(50) NOT NULL,
  UserID NUMBER NOT NULL,
  Timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE
);

CREATE OR REPLACE PROCEDURE Perform_Calculation (
  p_name IN VARCHAR2,
  p_email IN VARCHAR2,
  p_num1 IN NUMBER,
  p_num2 IN NUMBER,
  p_operator IN VARCHAR2
) AS
  v_user_id NUMBER;
  v_result NUMBER;
  v_version NUMBER := 1;
BEGIN
  -- Check if the user already exists
  SELECT UserID INTO v_user_id FROM Users WHERE Email = p_email;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      -- If the user doesn't exist, insert them
      INSERT INTO Users (Name, Email, PasswordHash, Role) VALUES (p_name, p_email, 'password_hash', 'user')
      RETURNING UserID INTO v_user_id;
  END;

  -- Perform the calculation
  CASE p_operator
    WHEN '+' THEN v_result := p_num1 + p_num2;
    WHEN '-' THEN v_result := p_num1 - p_num2;
    WHEN '*' THEN v_result := p_num1 * p_num2;
    WHEN '/' THEN
      IF p_num2 != 0 THEN
        v_result := p_num1 / p_num2;
      ELSE
        RAISE_APPLICATION_ERROR(-20001, 'Division by zero is not allowed.');
      END IF;
    ELSE
      RAISE_APPLICATION_ERROR(-20002, 'Invalid operator. Use one of +, -, *, /.');
  END CASE;
  -- Get the last version for this user and increment the version
  SELECT NVL(MAX(Version), 0) + 1 INTO v_version FROM Calculations WHERE UserID = v_user_id;

  -- Insert the calculation record with the new version
  INSERT INTO Calculations (UserID, Num1, Num2, Operator, Result, Version)
  VALUES (v_user_id, p_num1, p_num2, p_operator, v_result, v_version);

  -- Insert an audit log record
  INSERT INTO AuditLogs (TableName, Operation, UserID, Timestamp)
  VALUES ('Calculations', 'INSERT', v_user_id, SYSTIMESTAMP);

  COMMIT;
END;

CREATE OR REPLACE TRIGGER Increment_Calculation_Version
BEFORE INSERT ON Calculations
FOR EACH ROW
DECLARE
  v_latest_version NUMBER;
BEGIN
  -- Get the current max version for the user
  SELECT NVL(MAX(Version), 0) INTO v_latest_version
  FROM Calculations
  WHERE UserID = :NEW.UserID;

  -- Set the new version
  :NEW.Version := v_latest_version + 1;
END;

CREATE OR REPLACE TRIGGER Audit_Calculation_Insert
AFTER INSERT ON Calculations
FOR EACH ROW
BEGIN
  -- Insert an audit log record
  INSERT INTO AuditLogs (TableName, Operation, UserID, Timestamp)
  VALUES ('Calculations', 'INSERT', :NEW.UserID, SYSTIMESTAMP);
END;

CREATE OR REPLACE TRIGGER Audit_Calculation_Update
AFTER UPDATE ON Calculations
FOR EACH ROW
BEGIN
  -- Insert an audit log record
  INSERT INTO AuditLogs (TableName, Operation, UserID, Timestamp)
  VALUES ('Calculations', 'UPDATE', :NEW.UserID, SYSTIMESTAMP);
END;

CREATE OR REPLACE TRIGGER Audit_Calculation_Delete
AFTER DELETE ON Calculations
FOR EACH ROW
BEGIN
  -- Insert an audit log record
  INSERT INTO AuditLogs (TableName, Operation, UserID, Timestamp)
  VALUES ('Calculations', 'DELETE', :OLD.UserID, SYSTIMESTAMP);
END;